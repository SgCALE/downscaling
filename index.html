<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">

<script src="./slider.js"></script>
<link rel="stylesheet" href="./layout/style.css">
  
</head>
<body>

<div class="header">
<img src="./logo/prjlogo.svg" alt="nuslog" width="100" >
</div>

<div id="navbar">
  <a class="active" href="./index.html">Home</a>
  <a href="./people.html">People</a>
  <a href="./publication.html">Publication</a>
  <a href="./about.html">About</a>
  <a href="./contact.html">Contact</a>
</div>

<div
  <h1 style="font-size:200%; padding-left:25%; padding-right:25%;">Climate Models</h1>
  <p style="font-size:50%; padding-left:0%; padding-right:0%; text-align:justify;"> Global climate models (GCMs) under Coupled Model Intercomparison Project 6 (CMIP6) have been widely used to investigate climate change impacts and put forward associated adaptation and mitigation strategies. However, the relatively coarse spatial resolutions (usually 100~300km) preclude their direct applications in regional scales, where the analysis (e.g., hydrological model simulation) is applied. To bridge this gap, a typical approach is to ‘refine’ the information from GCMs through regional climate downscaling experiments, which can be conducted statistically, dynamically, or a combination thereof. Statistical downscaling establishes relationships between large-scale climate indicators and small-scale climate variables in the reference (historical) period. Subsequently, these relationships are kept unchanged in the future and used to predict the future variables. On the other hand, dynamical downscaling operates based on the physical processes and the associated interactions in the climate systems and thus can produce a full set of regional climate simulations (e.g., temperature and precipitation fields) that are dynamically consistent. However, traditional dynamical downscaling contains significant biases that are transferred from GCMs and may be enhanced during the process of downscaling, thus degrading the downscaled results. One approach to remove these biases is the hybrid statistical-dynamical downscaling, where GCMs are firstly bias corrected, and subsequently used as lower and lateral boundary conditions to drive the regional climate models (RCMs).</p>
</div>
<!--<div class="titlesty">-->
<div
  <h1 style="font-size:200%; padding-left:25%; padding-right:25%;">Hybrid statistical-dynamical downscaling</h1>
  <p style="font-size:50%; padding-left:0%; padding-right:0%; text-align:justify;">In this work, we apply a hybrid statistical-dynamical downscaling, following the approach of Xu et al., 2021. We establish a bias-corrected and downscaled dataset based on 14 CMIP6 GCMs and the European Centre for Medium -Range Weather Forecasts Reanalysis 5 (ERA5) dataset. The bias-corrected dataset is adjusted to resemble ERA5-based mean climate and interannual variance, and with a non-linear trend from the ensemble mean of the 14 CMIP6 models. The dataset spans a historical period of 1979–2014 and future scenarios (SSP585) of 2015–2100, with a temporal scale of six-hour. The main contributions of this dataset are twofold, 1) we provide the open- source and high-resolution (12.5km: southeast Asia; 2.5km: around Singapore; 500m: Singapore, as shown in Fig. datasets, including precipitation, wind, temperature, radiation, etc; 2) this bias-corrected and downscaled dataset is of better quality than the existing dynamical work (e.g., CORDEX) in southeast Asia in terms of its ability to reproduce regional climate extremes, spatial patterns, etc. This dataset will be useful for policy-makers and researchers to make the pathways for resilient planning to reduce climate change impacts.</p>
</div>

<div class="img-comp-container">
    <div class="img-comp-img">
        <img id="left-temp"
             src="./images/t2_include_oce.d01.2083.png"
             width="800px" height="800px" >
    </div>
    <div class="img-comp-img img-comp-overlay">
        <img id="right-temp"
             src="./images/t2_include_oce.d00gcm.2083.png"
             width="800px" height="800px" >
    </div>
    <!-- id's are not needed but wrapping all the buttons in a common ancestor will help -->
    <div class="buttonContainer">
          <input class="button" type="button" value="Great Southeast Asia">
          <input class="button" type="button" value="Southeast Asia">
          <input class="button" type="button" value="Around Singapore">
          <input class="button" type="button" value="Singapore">
    </div>
</div>

<div class="img-comp-container">
    <div class="img-comp-img">
        <img id="left-prep"
             src="./images/pre_include_oce.d00gcm.2083.png"
             width="800px" height="800px" >
    </div>
    <div class="img-comp-img img-comp-overlay">
        <img id="right-prep"
             src="./images/pre_include_oce.d01.2083.png"
             width="800px" height="800px" >
    </div>
    <!-- id's are not needed but wrapping all the buttons in a common ancestor will help -->
    <div class="buttonContainer">
          <input class="button" type="button" value="Great Southeast Asia">
          <input class="button" type="button" value="Southeast Asia">
          <input class="button" type="button" value="Around Singapore">
          <input class="button" type="button" value="Singapore">
    </div>
</div>

<script>
// Instead of setting up 4 separate event handlers that all point to the
// same callback function, we can use event delegation where we handle the
// event on an ancestor object of all the elements we care about

/*find all elements with an "buttonContainer" class:*/
  x = document.getElementsByClassName("buttonContainer");
  temp_button = x[0]
  prep_button = x[1]
  temp_button.addEventListener("click", temp);
  prep_button.addEventListener("click", prep);


// Store all the images in an array
var prepleft_backgrounds = [
"./images/pre_include_oce.d01.2083.png",
"./images/presea.d02.2083.png",
"./images/pre.malai.d03.2083.png",
"./images/pre.sg.d04.2083.png"

];
var prerpright_backgrounds = [
"./images/pre_include_oce.d00gcm.2083.png",
"./images/presea.d01.2083.png",
"./images/pre.malai.d02.2083.png",
"./images/pre.sg.d03.2083.png"
];
var t2left_backgrounds = [
"./images/t2_include_oce.d01.2083.png",
"./images/t2sea.d02.2083.png",
"./images/t2.malai.d03.2083.png",
"./images/t2.sg.d04.2083.png"

];
var t2right_backgrounds = [
"./images/t2_include_oce.d00gcm.2083.png",
"./images/t2sea.d01.2083.png",
"./images/t2.malai.d02.2083.png",
"./images/t2.sg.d03.2083.png"
];
// Get a reference to the output element
var left_temp = document.getElementById("left-temp");
var right_temp = document.getElementById("right-temp");

// Get a reference to the output element
var left_prep = document.getElementById("left-prep");
var right_prep = document.getElementById("right-prep");

// All event handling functions are automatically passed an argument
// that is a reference to the event object itself
function temp(event){
// Just set the background image based on the index of the button
// that got clicked within its parent and the corresponding index
// of the image in the array

// Get all the <input> elements
var buttons = temp_button.querySelectorAll("input");


// Convert that node list into an array and get the index of the
// one that got clicked (event.target is the one that got clicked)
var index = (Array.prototype.slice.call(buttons)).indexOf(event.target);

// Set the background to the right image from the array
   left_temp.src = t2left_backgrounds[index]
   right_temp.src = t2right_backgrounds[index]
}

// All event handling functions are automatically passed an argument
// that is a reference to the event object itself
function prep(event){
// Just set the background image based on the index of the button
// that got clicked within its parent and the corresponding index
// of the image in the array

// Get all the <input> elements
var buttons = prep_button.querySelectorAll("input");

// Convert that node list into an array and get the index of the
// one that got clicked (event.target is the one that got clicked)
var index = (Array.prototype.slice.call(buttons)).indexOf(event.target);

// Set the background to the right image from the array
   left_prep.src = prepleft_backgrounds[index]
   right_prep.src = prepright_backgrounds[index]
}

</script>
<script>
/*Execute a function that will execute an image compare function for each element with the img-comp-overlay class:*/
window.onload = function() {initComparisons()};
window.onscroll = function() {myFunction()};

var navbar = document.getElementById("navbar");
var sticky = navbar.offsetTop;

function myFunction() {
  if (window.pageYOffset >= sticky) {
    navbar.classList.add("sticky")
  } else {
    navbar.classList.remove("sticky");
  }
}
</script>

</body>
</html>
